{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["type FetchFunc<Result, Input> = (input: Input) => Promise<Result>;\n\n/**\n * fetch store\n *\n * `get` will throw a promise when a result is not ready.\n * `prefetch` will start fetching.\n * `evict` will remove a result.\n * If `input` is an object, a result will be stored in WeakMap.\n * Othrewise, a result will be stored in Map.\n */\nexport type FetchStore<Result, Input> = {\n  get: (input: Input) => Result;\n  prefetch: (input: Input) => void;\n  evict: (input: Input) => void;\n};\n\nconst isObject = (x: unknown): x is object => typeof x === 'object' && x !== null;\n\n/**\n * create fetch store\n *\n * @example\n * import { createFetchStore } from 'react-suspense-fetch';\n *\n * const fetchFunc = async (userId) => (await fetch(`https://reqres.in/api/users/${userId}?delay=3`)).json();\n * const store = createFetchStore(fetchFunc);\n * store.prefetch('1');\n */\nexport function createFetchStore<Result, Input>(\n  fetchFunc: FetchFunc<Result, Input>,\n  preloaded?: Iterable<readonly [Input, Result]>,\n) {\n  type GetResult = () => Result;\n  const cache = new Map<Input, GetResult>();\n  const weakCache = new WeakMap<object, GetResult>();\n  if (preloaded) {\n    for (const [input, result] of preloaded) {\n      if (isObject(input)) {\n        weakCache.set(input, () => result);\n      } else {\n        cache.set(input, () => result);\n      }\n    }\n  }\n  const createGetResult = (input: Input) => {\n    let promise: Promise<void> | null = null;\n    let result: Result | null = null;\n    let error: Error | null = null;\n    promise = (async () => {\n      try {\n        result = await fetchFunc(input);\n      } catch (e) {\n        error = e;\n      } finally {\n        promise = null;\n      }\n    })();\n    const getResult = () => {\n      if (promise) throw promise;\n      if (error !== null) throw error;\n      return result as Result;\n    };\n    return getResult;\n  };\n  const prefetch = (input: Input) => {\n    if (isObject(input)) {\n      if (!weakCache.has(input)) {\n        weakCache.set(input, createGetResult(input));\n      }\n      return;\n    }\n    if (!cache.has(input)) {\n      cache.set(input, createGetResult(input));\n    }\n  };\n  const evict = (input: Input) => {\n    if (isObject(input)) {\n      weakCache.delete(input);\n    } else {\n      cache.delete(input);\n    }\n  };\n  const store: FetchStore<Result, Input> = {\n    prefetch,\n    evict,\n    get: (input: Input) => {\n      let getResult = isObject(input) ? weakCache.get(input) : cache.get(input);\n      if (!getResult) {\n        prefetch(input);\n        getResult = (\n          isObject(input) ? weakCache.get(input) : cache.get(input)\n        ) as GetResult;\n      }\n      return getResult();\n    },\n  };\n  return store;\n}\n"],"names":["isObject","x","fetchFunc","preloaded","cache","Map","weakCache","WeakMap","input","result","set","createGetResult","promise","error","e","prefetch","has","evict","get","getResult"],"mappings":"sVAiBA,IAAMA,EAAW,SAACC,SAAyC,iBAANA,GAAwB,OAANA,+BAarEC,EACAC,GAGA,IAAMC,EAAQ,IAAIC,IACZC,EAAY,IAAIC,QACtB,GAAIJ,EACF,qCAAYK,OAAOC,OACbT,EAASQ,GACXF,EAAUI,IAAIF,EAAO,kBAAMC,IAE3BL,EAAMM,IAAIF,EAAO,kBAAMC,grBAJGN,sBAQhC,IAAMQ,EAAkB,SAACH,GACvB,IAAII,EAAgC,KAChCH,EAAwB,KACxBI,EAAsB,KAe1B,OAdAD,EAAU,qRAESV,EAAUM,qBAAzBC,gBACOK,GACPD,EAAQC,sBAERF,EAAU,wFANJ,mCAAA,GASQ,WAChB,GAAIA,EAAS,MAAMA,EACnB,GAAc,OAAVC,EAAgB,MAAMA,EAC1B,OAAOJ,IAILM,EAAW,SAACP,GACZR,EAASQ,GACNF,EAAUU,IAAIR,IACjBF,EAAUI,IAAIF,EAAOG,EAAgBH,IAIpCJ,EAAMY,IAAIR,IACbJ,EAAMM,IAAIF,EAAOG,EAAgBH,KAwBrC,MAdyC,CACvCO,SAAAA,EACAE,MATY,SAACT,GACTR,EAASQ,GACXF,SAAiBE,GAEjBJ,SAAaI,IAMfU,IAAK,SAACV,GACJ,IAAIW,EAAYnB,EAASQ,GAASF,EAAUY,IAAIV,GAASJ,EAAMc,IAAIV,GAOnE,OANKW,IACHJ,EAASP,GACTW,EACEnB,EAASQ,GAASF,EAAUY,IAAIV,GAASJ,EAAMc,IAAIV,IAGhDW"}